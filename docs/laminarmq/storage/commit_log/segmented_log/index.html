<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A `CommitLog` implemented as a collection of segment files."><title>laminarmq::storage::commit_log::segmented_log - Rust</title><script> if (window.location.protocol !== "file:") document.write(`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2">`)</script><link rel="stylesheet" href="../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-e935ef01ae1c1829.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="laminarmq" data-themes="" data-resource-suffix="" data-rustdoc-version="1.78.0 (9b00956e5 2024-04-29)" data-channel="1.78.0" data-search-js="search-42d8da7a6b9792c2.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../static.files/storage-4c98445ec4002617.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../../static.files/main-12cf3b4f4f9dc36d.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../laminarmq/index.html">laminarmq</a><span class="version">0.0.5</span></h2></div><h2 class="location"><a href="#">Module segmented_log</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#types">Type Aliases</a></li></ul></section><h2><a href="../index.html">In laminarmq::storage::commit_log</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../../laminarmq/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../../index.html">laminarmq</a>::<wbr><a href="../../index.html">storage</a>::<wbr><a href="../index.html">commit_log</a>::<wbr><a class="mod" href="#">segmented_log</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../../src/laminarmq/storage/commit_log/segmented_log/mod.rs.html#1-1990">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A <a href="../trait.CommitLog.html" title="trait laminarmq::storage::commit_log::CommitLog"><code>CommitLog</code></a> implemented as a collection of segment files.</p>
<p>The segmented-log data structure for storing was originally described in the <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2017/09/Kafka.pdf">Apache
Kafka</a> paper.</p>
<p align="center">
<img src="https://raw.githubusercontent.com/arindas/laminarmq/assets/assets/diagrams/laminarmq-indexed-segmented-log-landscape.svg" alt="segmented_log" />
</p>
<p>A segmented log is a collection of read segments and a single write segment. Each “segment” is
backed by a storage file on disk called “store”.</p>
<p>The log is:</p>
<ul>
<li>“immutable”, since only “append”, “read” and “truncate” operations are allowed. It is not possible
to update or delete records from the middle of the log.</li>
<li>“segmented”, since it is composed of segments, where each segment services records from a
particular range of offsets.</li>
</ul>
<p>All writes go to the write segment. A new record is written at the <code>highest_index</code>
in the write segment. When we max out the capacity of the write segment, we close the write segment
and reopen it as a read segment. The re-opened segment is added to the list of read segments. A new
write segment is then created with <code>base_index</code> equal to the <code>highest_index</code> of the previous write
segment.</p>
<p>When reading from a particular index, we linearly check which segment contains the given read
segment. If a segment capable of servicing a read from the given index is found, we read from that
segment. If no such segment is found among the read segments, we default to the write segment. The
following scenarios may occur when reading from the write segment in this case:</p>
<ul>
<li>The write segment has synced the messages including the message at the given offset. In this case
the record is read successfully and returned.</li>
<li>The write segment hasn’t synced the data at the given offset. In this case the read fails with a
segment I/O error.</li>
<li>If the offset is out of bounds of even the write segment, we return an “out of bounds” error.</li>
</ul>
<h5 id="laminarmq-specific-enhancements-to-the-segmented_log-data-structure"><a class="doc-anchor" href="#laminarmq-specific-enhancements-to-the-segmented_log-data-structure">§</a><code>laminarmq</code> specific enhancements to the <code>segmented_log</code> data structure</h5>
<p>Originally, the <code>segmented_log</code> addressed individual records with “offsets” which were continous
accross all the segments. While the conventional <code>segmented_log</code> data structure is quite performant
for a <code>commit_log</code> implementation, it still requires the following properties to hold true for the
record being appended:</p>
<ul>
<li>We have the entire record in memory</li>
<li>We know the record bytes’ length and record bytes’ checksum before the record is appended</li>
</ul>
<p>It’s not possible to know this information when the record bytes are read from an asynchronous
stream of bytes. Without the enhancements, we would have to concatenate intermediate byte buffers to
a vector. This would not only incur more allocations, but also slow down our system.</p>
<p>Hence, to accommodate this use case, we introduced an intermediate indexing layer to our design.</p>
<div class="example-wrap"><pre class="language-text"><code>//! Index and position invariants across segmented_log

// segmented_log index invariants
segmented_log.lowest_index  = segmented_log.read_segments[0].lowest_index
segmented_log.highest_index = segmented_log.write_segment.highest_index

// record position invariants in store
records[i+1].position = records[i].position + records[i].record_header.length

// segment index invariants in segmented_log
segments[i+1].base_index = segments[i].highest_index
                         = segments[i].index[index.len-1].index + 1
</code></pre></div><p align="center">
<b>Fig:</b> Data organisation for persisting the <code>segmented_log</code> data structure on a
<code>*nix</code> file system.
</p>
<p>In the design, instead of referring to records with a raw offset, we refer to them with indices.
The index in each segment translates the record indices to raw file position in the segment store
file.</p>
<p>Now, the store append operation accepts an asynchronous stream of bytes instead of a contiguously
laid out slice of bytes. We use this operation to write the record bytes, and at the time of writing
the record bytes, we calculate the record bytes’ length and checksum. Once we are done writing the
record bytes to the store, we write it’s corresponding <code>record_header</code> (containing the checksum and
length), position and index as an <code>index_record</code> in the segment index.</p>
<p>This provides two quality of life enhancements:</p>
<ul>
<li>Allow asynchronous streaming writes, without having to concatenate intermediate byte buffers</li>
<li>Records are accessed much more easily with easy to use indices</li>
</ul>
<p>Now, to prevent a malicious user from overloading our storage capacity and memory with a maliciously
crafted request which infinitely loops over some data and sends it to our server, we have provided
an optional <code>append_threshold</code> parameter to all append operations. When provided, it prevents
streaming append writes to write more bytes than the provided <code>append_threshold</code>.</p>
<p>At the segment level, this requires us to keep a segment overflow capacity. All segment append
operations now use <code>segment_capacity - segment.size + segment_overflow_capacity</code> as the
<code>append_threshold</code> value. A good <code>segment_overflow_capacity</code> value could be <code>segment_capacity / 2</code>.</p>
<h3 id="why-is-this-nested-as-a-submodule"><a class="doc-anchor" href="#why-is-this-nested-as-a-submodule">§</a>Why is this nested as a submodule?</h3>
<p>There can be other implementations of a <a href="../trait.CommitLog.html" title="trait laminarmq::storage::commit_log::CommitLog"><code>CommitLog</code></a> which have a completely different
structure. So we make “segmented-log” a submodule to represent it as one of the possible
implementations.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="index/index.html" title="mod laminarmq::storage::commit_log::segmented_log::index">index</a></div><div class="desc docblock-short">Provides components necessary for mapping record indices to store-file positions in segments.</div></li><li><div class="item-name"><a class="mod" href="segment/index.html" title="mod laminarmq::storage::commit_log::segmented_log::segment">segment</a></div><div class="desc docblock-short">Presents the <code>segment</code> units that a <code>segmented-log</code> is made out of.</div></li><li><div class="item-name"><a class="mod" href="store/index.html" title="mod laminarmq::storage::commit_log::segmented_log::store">store</a></div><div class="desc docblock-short">Present the backing storage components for a <code>segment</code> in a <code>segmented-log</code>.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Config.html" title="struct laminarmq::storage::commit_log::segmented_log::Config">Config</a></div><div class="desc docblock-short">Configuration for <a href="struct.SegmentedLog.html" title="struct laminarmq::storage::commit_log::segmented_log::SegmentedLog"><code>SegmentedLog</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.MetaWithIdx.html" title="struct laminarmq::storage::commit_log::segmented_log::MetaWithIdx">MetaWithIdx</a></div><div class="desc docblock-short">Represents metadata for <a href="type.Record.html" title="type laminarmq::storage::commit_log::segmented_log::Record"><code>Record</code></a> instances in the <a href="struct.SegmentedLog.html" title="struct laminarmq::storage::commit_log::segmented_log::SegmentedLog"><code>SegmentedLog</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.SegmentedLog.html" title="struct laminarmq::storage::commit_log::segmented_log::SegmentedLog">SegmentedLog</a></div><div class="desc docblock-short">The <a href="struct.SegmentedLog.html" title="struct laminarmq::storage::commit_log::segmented_log::SegmentedLog"><code>SegmentedLog</code></a> abstraction, implementing a <a href="../trait.CommitLog.html" title="trait laminarmq::storage::commit_log::CommitLog"><code>CommitLog</code></a> with a collection of <em>read</em>
<a href="segment/struct.Segment.html" title="struct laminarmq::storage::commit_log::segmented_log::segment::Segment"><code>Segment</code></a><code>s</code> and a single <em>write</em> <a href="segment/struct.Segment.html" title="struct laminarmq::storage::commit_log::segmented_log::segment::Segment"><code>Segment</code></a>.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.SegmentedLogError.html" title="enum laminarmq::storage::commit_log::segmented_log::SegmentedLogError">SegmentedLogError</a></div><div class="desc docblock-short">Error type associated with <a href="struct.SegmentedLog.html" title="struct laminarmq::storage::commit_log::segmented_log::SegmentedLog"><code>SegmentedLog</code></a> operations.</div></li><li><div class="item-name"><a class="enum" href="enum.SeqRead.html" title="enum laminarmq::storage::commit_log::segmented_log::SeqRead">SeqRead</a></div><div class="desc docblock-short">Returned by methods which allow manual resolution of which <a href="segment/struct.Segment.html" title="struct laminarmq::storage::commit_log::segmented_log::segment::Segment"><code>Segment</code></a> to read from in a
<a href="struct.SegmentedLog.html" title="struct laminarmq::storage::commit_log::segmented_log::SegmentedLog"><code>SegmentedLog</code></a>.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.LogError.html" title="type laminarmq::storage::commit_log::segmented_log::LogError">LogError</a></div><div class="desc docblock-short">Type alias for <a href="enum.SegmentedLogError.html" title="enum laminarmq::storage::commit_log::segmented_log::SegmentedLogError"><code>SegmentedLogError</code></a> with additional type parameter trait bounds.</div></li><li><div class="item-name"><a class="type" href="type.Record.html" title="type laminarmq::storage::commit_log::segmented_log::Record">Record</a></div><div class="desc docblock-short">Record type alias for <a href="struct.SegmentedLog.html" title="struct laminarmq::storage::commit_log::segmented_log::SegmentedLog"><code>SegmentedLog</code></a> using <a href="struct.MetaWithIdx.html" title="struct laminarmq::storage::commit_log::segmented_log::MetaWithIdx"><code>MetaWithIdx</code></a> as the metadata.</div></li></ul></section></div></main></body></html>